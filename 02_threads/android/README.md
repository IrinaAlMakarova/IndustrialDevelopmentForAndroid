# Домашнее задание к занятию «Сетевые запросы: Main Thread & Background»

## Задача №1. Likes
Легенда
В проекте, который мы рассматривали на лекции, не реализованы лайки:

class PostRepositoryImpl: PostRepository {
    override fun likeById(id: Long) {
        // TODO: do this in homework
    }
}
Backend-разработчики наконец предоставили описание API для реализации:
1. Добавление лайка:
POST /api/posts/{id}/likes
2. Удаление лайка:
DELETE /api/posts/{id}/likes
Где {id} — это идентификатор поста.

В ответ на оба запроса сервер присылает JSON обновлённого поста, который можно использовать для отображения изменённого поста в ленте.

Задача

Реализуйте возможность ставить и снимать лайк в вашем проекте. Для этого используйте код сервера с лекции.

Обратите внимание: после выполнения запроса список постов нужно обновить, чтобы отображалось актуальное количество лайков. Подумайте, как это правильно сделать.


# Домашнее задание к занятию «Современные подходы работы с многопоточностью»

## Задача №1. OkHttp enqueue
Возьмите проект и мигрируйте всю функциональность с использованием функции thread на enqueue из OkHttp.

# Домашнее задание к занятию «Многопоточность в Android»

## Задача №1. Glide
Реализуйте отображение аватарок в вашем приложении.

В качестве библиотеки для загрузки изображений используйте Glide.

Аватары с сервера можно получить по адресу /avatars/{name}, где name — это имя файла, которое сервер возвращает в поле authorAvatar у поста. Обратите внимание, что сервер возвращает файл с задержкой в несколько секунд.

## Задача №2. Rounded
Заказчик хочет, чтобы аватарки были круглые. Поищите среди методов трансформации тот, который подойдёт для этой задачи.

# Домашнее задание к занятию «Retrofit (CRUD)»

## Задача №1. Buggy Server
Рассмотрте альтернативный, не очень частый сценарий: в 50 % случаев сервер будет присылать не 2xx коды ответа.

Возьмите сервер из каталога server и реализуйте обработку подобного рода ошибок. Как реализовать ошибку, вы решаете сами.

Необязательно: посмотрите в приложениях Android, как реализована обработка подобных ошибок с точки зрения интерфейса: дают ли пользователю элементы управления для повторения запроса. Попробуйте их реализовать.

Примечание*: стандартная CRUD-функциональность должна по-прежнему работать.